#!/usr/bin/env ruby

if ARGV.first == '--help' || ARGV.first == '-h'
  STDERR.puts "!--usage: #{$0} [--encode message...] < input.txt > output.txt"
  exit 1
end

# main: decoding
#
if ARGV.first != "--encode"
  x = STDIN.read.gsub(/[^\u200b\u200c]/,'')
  if x==''
    STDERR.puts "!--nothing to decode"
    exit 2
  end

  x.gsub!("\u200c", '0').gsub!("\u200b", '1')
  STDERR.puts "!--warning: size=#{x.size}, not a multiple of 8 bits"  if (x.size % 8) != 0

  puts x.scan(/.{1,8}/).collect { |b| b.to_i(2) }.pack("C*").force_encoding('utf-8')
  exit 0
end

# main: encoding
#
# U+200B: zero width space, representing the bit '1'
# U+200C: zero width nonjoiner, representing the bit '0'
# 
msg = (ARGV[1..-1].join ' ').bytes.collect { |i| sprintf("%08b", i) }.join
idx = 0
c = nil

while true
  unless c                              # skip extra spaces
    while c = STDIN.getc
      print c
      break  if c =~ /\s/
    end
  end

  c = STDIN.getc                        # skip to end of word
  break  unless c
  unless c =~ /\s/
    print c
    next
  end

  if c != ' '                           # ignore words not followed by a normal space
    print c
    c = nil
    next
  end

  print (msg[idx] == '0' ? "\u200c" : "\u200b") + ' '   # write next hidden bit
  idx += 1
  if idx == msg.size                    # are we done?
    r = STDIN.read
    print r  if r
    exit 0
  end

  c = nil                               # remember to skip extra spaces
end

STDERR.puts "\n!--error: base text is too short, still #{msg.size - idx} bits left"
exit 3
